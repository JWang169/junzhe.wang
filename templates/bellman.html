<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>Bellman-Ford</title>
  <link rel="stylesheet" href="../static/algos.css">

</head>
<body>
<nav id="navbar">
  <header>Bellman-Ford</header>
  <ul>
    <li><a class="nav-link" href="../index.html">HOMEPAGE</a></li>
    <li><a class="nav-link" href="notes.html">Notes</a></li>
    <li><a class="nav-link" href="note4java.html">Java</a></li>
    <li><a class="nav-link" href="bellman.html">Bellman-Ford Algorithm</a></li>
    <li><a class="nav-link" href="dijkstra.html">Dijstra's Algorithm</a></li>
    <li><a class="nav-link" href="kmp.html">KMP</a></li>
    <li><a class="nav-link" href="morris.html">Morris Traversal</a></li>
    <li><a class="nav-link" href="rabinKarp.html">Rabin Karp</a></li>
    <li><a class="nav-link" href="segmentTree.html">Segment Tree</a></li>
    <li><a class="nav-link" href="campusBikesII.html">Campus Bike Summary</a></li>
    <li><a class="nav-link" href="dpString.html">DP String Summary</a></li>
  </ul>
</nav>

<main id="main-doc">
  <section class="main-section">
    <header>Introduction</header>
    <p><strong>Bellman-Ford</strong> solves similar problems as Dijkstra's. With the same relexation: </p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">if</span> d[u] <span style="color: #666666">+</span> c(u, v) <span style="color: #666666">&lt;</span> d[v]:
      d[v] <span style="color: #666666">=</span> d[u] <span style="color: #666666">+</span> c(u, v)
</pre></div>
  </section>

  <section class="main-section">
    <header>Steps</header>
    <p>
      <ol>
        <li>Initialize distances from source to all vertices as infinite. </li>
        <li>Relex each edge. (Same relexation as Dijkstra's). Do it for (v-1) times, where v is the number of vertices in given graph.</li>
        <li>Relex again. If there is any change, there is a negtive circle in the graph.</li>
      </ol>
    </p>
  </section>

  <section class="main-section">
    <header>Analysis</header>
    <ul>
      <li>Bellman-Ford can detect negtive circle. After we update the graph for v - 1 times, we do it for one more round. If there is any change in the graph, there must be a negtive circle in that graph.</li>
    </ul>
  </section>
  
  <section class="main-section">
    <header>Implement</header>
    In most cases, we use heap (Priority Queue) to solve single source shortest path problem. We build the graph to store source and destination pairs with price. Graph[source][destination] = price. 
  </section>


  <section class="main-section"> 
    <header>Related Problems</header>
    <li><a href="https://leetcode.com/problems/maximum-vacation-days/">Leetcode 568</a> Maximum Vacation Days</li>
    <li><a href="https://leetcode.com/problems/minimize-malware-spread/">Leetcode 924</a> Minimize Malware Spread</li>
  </section>

</main>

</body>
</html>
