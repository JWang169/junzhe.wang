<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>J's Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
<link rel="stylesheet" href="../static/notes.css">

</head>
<body>
<!-- partial:index.partial.html -->
<header>
  <h1>ClipBoard&nbsp;&nbsp;<span>Welcome the my black parade. &nbsp;&nbsp;ðŸ‘½</span></h1>
</header>
<main>
  <div class="sidebar">
    <h2></h2>
    <ul>
      <li><a href="../index.html">HOME</a></li>
      <li><a href="resume.html">RESUME</a></li>
      <li><a href="cmd.html">CMD</a></li>
      <li><a href="note4java.html">&nbsp;Java</a></li>
      <li><a href="dpString.html">&nbsp;Notes</a></li>
    </ul>
  </div>
  <div class='grid'>
    <div class="block">
      <h3>Morris Traversal <a href="morris.html">&#x1F517</a> </h3>
      <p>Morris traversal is an inorder tree traversal algorithm which does not involve recursion or stack, which means it saves a lot of space compared with basic inorder traversal. </p><br>
    </div>
    <div class="block">
      <h3>KMP<a href="kmp.html">&#x1F517</a></h3>
      <p>KMP(Knuth-Morris-Pratt) is for pattern matching, including prefix, suffix, substring, etc. It can search for the pattern in linear time. If we do brute force, the time complexity will be O(m*n). If we do KMP, it will be O(m + n). The key step is to build the table for the pattern. We always need the table for KMP. </p><br>
      <P>Rabin Karp is a good replacement for KMP. </P>
    </div>
    <div class="block">
      <h3>Rabin Karp</h3>
      <p>The theory behind Rabin Karp is hash function. We map string to integer by a hash function. </p><br>
    </div>
      <div class="block">
      <div><br /><img src='http://placehold.it/350x350' /></div><br>
    </div>
    <div class="block">
      <h3>Dijkstra's Algorithm<a href="dijkstra.html">&#x1F517</a></h3></h3>
      <p>This is to solve single source shortest path problem</p>
      <p>A minimazation problem is an optimization problem. Optimization problem can be solved using greedy method. Greedy method says that a problem should be solved in stages by taking one step at a time and considering on input at a time to get an optimal solution. There are predefined procedures, and we follow that procedure to get an optimal result. So Dijkstra gives a procedure for getting an optimal solution that is minimum result, aka the shortest path. </p>
      <p>Dijkstra can work on both directed and non directed graphs. </p>
      <p>Relexation</p>
      <blockquote><code>if d[u] + c(u, v) < d[v]:
              d[v] = d[u] + c(u,v)
      </code></blockquote>
      <p>Process: 
          <ol>
            <li>Select a start vertex. </li>
            <li>Compute the distance to its connected vertices. </li>
            <li>Set the connected node with the shortest distance as the start point, and updates its neighbors. </li>
            <li>After all the vertices are updated as the start point, ends it. </li>
          </ol>
      </p>
      <p>Time complexity.
        <ul>
            We do not know how the vertices are connected to their neighbors. The worst scenario, all vertices connect to each other, then we have to update all vertices for n time, where n is the amount of vertices in the graph. The time complexity is O(n^2).
        </ul>
      </p>
      <p>Drawbacks</p>
      <ul>
        <li>
          If there is a negtive edge in the graph, it might not be correct. 
        </li>
      </ul>
    </div>
    <div class="block">
      <h3>Bellman-Ford Algorithm<a href="bellman.html">&#x1F517</a></h3></h3>
      <p>This solves similar problems as Dijkstra's. </p>
      <p>Process:
        <ol>
          <li>Initialize distances from source to all vertices as infinite. </li>
          <li>Relex each edge. (Same relexation as Dijkstra's). Do it for (v-1) times, where v is the number of vertices in given graph. </li>
          <li>Relex again. If there is any change, there is a negtive circle in the graph. </li>

        </ol>
      </p>
    </div>
    <div class="block">
      <div><br /><img src='http://placehold.it/350x350' /></div><br>
    </div>
    <div class="block">
      <h3 class='flag'>DP<a href="dpString.html">&#x1F517</a></h3> 
      <p>Consider using DP when you have to make choices to arrive at the solution, and you can construct a solution to the given instance from solutions to subinstances of smaller problems of the same kind. <br>
      DP is applicable to counting and decision problems. <br>
      Although DP involves recursion, often for efficiency the cache is built "bottom-up", ie., iteratively. <br>
      When DP is implemented recursively the cache is typically a dynamic data structure such as a hash table or a BST; When it is implemented iteratively the cache is usually a one or multi dimensional array. <br>
      Sometimes, recursion may out-perform a bottom-up DP solution, e.g., when the solution is found early or subproblems can be pruned through bounding. <br>



      </p>    
      
    </div>
    <div class="block">
      <h3 class='flag'>About The SSH</h3>
      <p>Secure Shell(SSH) is a cryptographic network protocol for operating network services securely over an unsecured network. It allows one computer(my computer) to securely connect to another computer(the web server) over an unsecured network like the internet. Without encryption, data travels over the web with plaintext, which makes it easy for someone to intercept informations such as username and password in plain text. With SSH, it encrypts your data through a tunnel, so you can securely log into a remote machine, securely transmit files, or safely issue commands. SSH is commonly implemented using the clinet-server model. In this case, my computer is called the SSH client, and another machine(web server) act as the SSH server. SSH can then be set up using a pair of keys: a public key stored on the SSH server, and a private key stored on the SSH client. The SSH client(my computer) will make contact with the SSH server, and provides the ID of the key pair to prove my identity.<br>If you want to use SSH on windows, you have to to install PuTTY first. Thank god I'm using a MAC. </p><br>
     </div>
    <div class="block">
      <div><br><img src='http://placehold.it/350x350' /></div><br>
    </div>
  </div>
  </div>
</main>
<footer>
  <ul>
    <li class='fontawesome-folder-open-alt'></li>
    <li class='fontawesome-print'></li>
    <li class='fontawesome-envelope-alt'></li>
    <li class='fontawesome-flag'></li>
    <li class='fontawesome-check'></li>
    <li class='fontawesome-calendar'></li>
  </ul>
</footer>
<!-- partial -->
  
</body>
</html>
